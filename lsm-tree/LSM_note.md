# 阅读 `LSM-tree` 文献笔记

`The Log-Structured Merge-Tree (LSM-Tree)`

## 1. `LSM-tree` 概念

高性能的事务型交易系统通常包括两个典型的任务：

- 往历史表中插入新的行数据；
- 同时生成日志记录以备系统恢复。

上述两种数据信息均依赖于有效的索引结构。

1. 基于标准磁盘的索引，例如 `B-tree` 结构，因为需要实时地维护索引结构，将会翻倍增加事务的 `I/O` 成本。

2. `LSM-tree` 是一种基于磁盘的数据结构，旨在为较长周期内记录插入（或删除）率较高的文件提供一种低成本的索引结构。

3. `LSM-tree` 使用一种算法来 **延迟** 和 **批处理** 索引更改，它以一种类似于归并排序的高效方式将更改从基于内存的组件级联到一个或多个磁盘组件。

这个算法极大地减少了磁盘臂的移动次数（相比于 `B-tree`），并在使用传统访问方法插入的磁盘臂成本超过存储介质成本的领域中提高了性价比。

`LSM-tree` 结构以批量顺序的方式写入数据，这种优化极大地减少了 `HDD` 的磁盘寻道时间和 `SSD` 的延迟。

## 2. `LSM-tree` 使用场景

LSM-tree 适合在索引插入更常见的场景中使用。因为，需要立即响应的索引查找将失去 I/O 效率。

## 3. 索引日志

随着交易流系统中不断增加的长事务，索引日志访问变得越来越重要。

## 4. `LSM-tree` 原理

一条新的记录存储在数据库中的过程：

1. 写入 WAL 日志文件（顺序写），用于崩溃恢复；
2. 插入内存缓冲区中的数据页；
3. 将内存中的脏页刷到磁盘上。

其中第 3 步有一定的延迟。因此，需要一种有效的方式将内存中的脏页及时刷新到磁盘：
当内存缓冲区的数据大小达到最大分配量的阈值时，正在进行的 `rolling merge` 进程就会删除内存缓冲区的脏页，并将它们合入到磁盘上。

## 5. `LSM-tree` 是如何工作的

`LSM-tree` 由两个树形数据结构的组件构成，一个是内存中的树($C_0$)，另一个是磁盘上的树($C_1$)。$C_1$ 是以 key 有序的方式存储在磁盘上的。
