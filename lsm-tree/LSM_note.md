# 阅读 `The Log-Structured Merge-Tree (LSM-Tree)` 文献笔记

- [1. `LSM-Tree` 概念](#1-lsm-tree-概念)
- [2. `LSM-Tree` 使用场景](#2-lsm-tree-使用场景)
- [3. 索引日志](#3-索引日志)
- [4. `LSM-Tree` 原理](#4-lsm-tree-原理)
- [5. `LSM-Tree` 是如何工作的](#5-lsm-tree-是如何工作的)
  - [5.1 MemTable](#51-memtable)


## 1. `LSM-Tree` 概念

高性能的事务型交易系统通常包括两个典型的任务：

1. 往历史表中插入新的行数据；
2. 同时生成日志记录以备系统恢复。

上述产生的数据信息均依赖于有效的索引结构实现快速地数据检索操作。

基于标准磁盘的索引，例如 `B-Tree` 结构，因为需要 **实时** 维护索引更新，将会翻倍增加事务的 `I/O` 成本，从而使得系统的总成本增加到 $50\%$。

因此，提出一种新的基于磁盘的 `LSM-Tree` 数据结构，旨在较长周期内为记录插入（或删除）率较高的文件提供一种 **低成本** 的索引。

## 2. `LSM-Tree` 实现思想

`LSM-Tree` 使用一种 **延迟** 和 **批处理** 索引更新的算法，并以类似于归并排序的高效方式将索引更改从基于内存的组件级联到一个或多个磁盘组件。

与传统访问方法（例如 `B-Tree`）相比，该算法极大地减少了磁盘臂的移动次数，从而在磁盘臂操作成本超过存储介质成本的领域中，可显著地提高系统的性价比。

`LSM-Tree` 适合在索引插入更常见的场景中使用，即 **写多读少** 的场景。因为，需要立即响应的索引查找将失去 I/O 效率。

## 3. 索引日志

随着交易流系统中不断增加的长事务，索引日志访问变得越来越重要。

## 4. `LSM-Tree` 原理

`LSM-Tree` 结构以 **批量顺序** 的方式写入数据，这种优化极大地减少了 `HDD` 的磁盘寻道时间和 `SSD` 的延迟。

一条新的记录存储在数据库中的过程：

1. 写入 WAL 日志文件（顺序写），用于崩溃恢复；
2. 插入内存缓冲区中的数据页；
3. 将内存中的脏页刷到磁盘上。

其中第 3 步有一定的延迟。因此，需要一种有效的方式将内存中的脏页及时刷新到磁盘：
当内存缓冲区的数据大小达到最大分配量的阈值时，正在进行的 `rolling merge` 进程就会删除内存缓冲区的脏页，并将它们合入到磁盘上。

## 5. `LSM-Tree` 是如何工作的

`LSM-Tree` 由两个树形数据结构的组件构成，一个是内存中的树($C_0$)，另一个是磁盘上的树($C_1$)。$C_1$ 是以 key 有序的方式存储在磁盘上的。

### 5.1. MemTable

`MemTable` 是一个内存中的数据结构，以 **追加写** 的方式存储数据。
